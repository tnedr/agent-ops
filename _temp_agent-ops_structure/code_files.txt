# === CODE MODULES ===
Total files: 2
Total characters: 10,561
Estimated tokens: 2,640

# === CODE FILES TOC ===
E:\Repos\agent-ops\actions\pr-bot\entrypoint.sh [270.0B]
E:\Repos\agent-ops\actions\pr-bot\pr_bot.py [10.0KB]

# === FILE: actions\pr-bot\entrypoint.sh ===
# Path: actions\pr-bot\entrypoint.sh
# Type: sh
# Size: 270.0B
# Modified: 2025-11-04T13:39:24.391117

#!/bin/sh
set -e

# Build arguments array based on inputs
ARGS=""

if [ "$INPUT_CI" = "true" ]; then
    ARGS="$ARGS --ci"
fi

if [ "$INPUT_FORCE" = "true" ]; then
    ARGS="$ARGS --force"
fi

# Execute the Python script with arguments
exec python /app/pr_bot.py $ARGS



# === FILE: actions\pr-bot\pr_bot.py ===
# Path: actions\pr-bot\pr_bot.py
# Type: py
# Size: 10.2KB
# Modified: 2025-11-04T13:39:24.392117

#!/usr/bin/env python3

"""

pr_bot.py ‚Äì One‚Äëshot GitHub PR automator (v2.3)



==============================================



‚¨ÜÔ∏è *NEW in 2.3*



‚Ä¢ **--force flag** ‚Äì Admin override-dal merge-el, akkor is ha piros check-ek vannak



‚Ä¢ **Configurable CI polling** ‚Äì CI_POLL_INTERVAL be√°ll√≠that√≥ PR_BOT_POLL env v√°ltoz√≥val



‚Ä¢ **Token check** ‚Äì Ellen≈ërzi a GitHub authentication-t ind√≠t√°skor



‚¨ÜÔ∏è *NEW in 2.2*



‚Ä¢ **Simplified workflow** ‚Äì Alap√©rtelmezetten kikapcsolva a CI polling, azonnal merge-el



‚Ä¢ **--ci** z√°szl√≥: Ha sz√ºks√©ges, be lehet kapcsolni a CI pollingot



‚Ä¢ **Reduced wait time** ‚Äì Alap√©rtelmezett v√°rakoz√°si id≈ë 60 m√°sodpercr≈ël 5 m√°sodpercre cs√∂kkentve



M≈±k√∂d√©s: branch l√©trehoz√°s ‚Üí commit ‚Üí PR megnyit√°sa ‚Üí r√∂vid v√°rakoz√°s ‚Üí squash‚Äëmerge ‚Üí branch t√∂rl√©s.



Ha a --ci flag meg van adva, akkor CI polling is t√∂rt√©nik a merge el≈ëtt.



"""



from __future__ import annotations



import argparse

import json

import os

import re

import shlex

import subprocess

import sys

import time

from typing import Any, List



CI_POLL_INTERVAL = int(os.getenv("PR_BOT_POLL", "30"))  # seconds per poll (configurable via env)

CI_POLL_TIMEOUT  = 30 * 60 # give up after 30 minutes



# ---------------- helpers ----------------



def run(cmd: str, capture: bool = False) -> str | None:

    """Run shell command, optionally return stdout."""

    if capture:

        proc = subprocess.run(cmd, shell=True, text=True,

                              stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

        if proc.returncode != 0:

            raise subprocess.CalledProcessError(proc.returncode, cmd, proc.stdout)

        return proc.stdout.strip()

    subprocess.check_call(cmd, shell=True)

    return None



def check_auth() -> None:

    """Check GitHub authentication status with friendly error message."""

    # In GitHub Actions, GITHUB_TOKEN is automatically available

    if "GITHUB_TOKEN" in os.environ:

        # Set up gh CLI with token

        os.environ["GH_TOKEN"] = os.environ["GITHUB_TOKEN"]

        try:

            run("gh auth status --silent", capture=True)

        except subprocess.CalledProcessError:

            # Authenticate with token

            token = os.environ["GITHUB_TOKEN"]

            run(f'echo "{token}" | gh auth login --with-token', capture=True)

    else:

        try:

            run("gh auth status --silent", capture=True)

        except subprocess.CalledProcessError:

            print("ERROR: GitHub authentication required.")

            print("Please run: gh auth login")

            print("Or set GITHUB_TOKEN environment variable.")

            sys.exit(1)



# ---------------- PR helpers ------------



def get_current_pr_number() -> int | None:

    """Get current PR number from GitHub Actions context or environment."""

    # Try to get from environment (GitHub Actions sets this)

    pr_number = os.getenv("PR_NUMBER")

    if pr_number:

        try:

            return int(pr_number)

        except ValueError:

            pass

    

    # Try to get from GITHUB_REF or GITHUB_EVENT_PATH

    github_ref = os.getenv("GITHUB_REF", "")

    if github_ref:

        match = re.search(r"pull/(\d+)", github_ref)

        if match:

            return int(match.group(1))

    

    # Try to read from GITHUB_EVENT_PATH

    event_path = os.getenv("GITHUB_EVENT_PATH")

    if event_path:

        try:

            with open(event_path, 'r') as f:

                event_data = json.load(f)

                pr_number = event_data.get("pull_request", {}).get("number")

                if pr_number:

                    return int(pr_number)

        except (FileNotFoundError, json.JSONDecodeError, KeyError):

            pass

    

    # Fallback: try to detect from current branch

    try:

        branch = run("git branch --show-current", capture=True)

        if branch:

            out = run(f"gh pr list --head {shlex.quote(branch)} --json number", capture=True)

            lst: List[Any] = json.loads(out)

            if lst:

                return int(lst[0]["number"])

    except (subprocess.CalledProcessError, json.JSONDecodeError):

        pass

    

    return None



def open_pr(title: str, body: str, base: str, branch: str) -> int:

    """Open (or detect existing) PR, return its number."""

    trials = [

        f"gh pr create --title {json.dumps(title)} --body {json.dumps(body)} "

        f"--label agent --base {shlex.quote(base)} --json number,state",

        f"gh pr create --title {json.dumps(title)} --body {json.dumps(body)} "

        f"--label agent --base {shlex.quote(base)}",

        f"gh pr create --title {json.dumps(title)} --body {json.dumps(body)} "

        f"--base {shlex.quote(base)}",

    ]

    for cmd in trials:

        try:

            out = run(cmd, capture=True)

            try:

                js = json.loads(out)

                return int(js["number"] if isinstance(js, dict) else js[0]["number"])

            except json.JSONDecodeError:

                m = re.search(r"/pull/(\d+)|#(\d+)", out)

                if m:

                    return int([g for g in m.groups() if g][0])

        except subprocess.CalledProcessError:

            continue

    # fallback list

    out = run(f"gh pr list --head {shlex.quote(branch)} --json number", capture=True)

    try:

        lst: List[Any] = json.loads(out)

        if lst:

            return int(lst[0]["number"])

    except json.JSONDecodeError:

        pass

    raise RuntimeError("Could not open PR or find its number.")



# -------------- CI polling --------------



def no_ci_output(text: str) -> bool:

    txt = text.lower()

    keywords = ["no checks reported", "pull request not found", "no status checks",

                "has no check runs"]

    return any(k in txt for k in keywords)



def ci_checks_green(pr: int, timeout: int, force: bool = False) -> bool:

    if force:

        print("‚ö†Ô∏è  --force flag set: skipping CI checks")

        return True

    

    start = time.time()

    while True:

        if time.time() - start > timeout:

            print("‚è∞ CI polling timed out.")

            return False

        try:

            out = run(f"gh pr checks {pr} --json status,state", capture=True)

            checks = json.loads(out)

        except subprocess.CalledProcessError as err:

            if no_ci_output(err.args[2] if len(err.args) > 2 else str(err)):

                print("‚ÑπÔ∏è  No CI configured ‚Äì skipping checks.")

                return True

            else:

                print("‚ùå gh pr checks failed, will retry ‚Ä¶")

        except json.JSONDecodeError:

            if no_ci_output(out):

                print("‚ÑπÔ∏è  No CI configured ‚Äì skipping checks.")

                return True

            # textual listing fallback

            if any(word in out for word in ("FAIL", "ERROR")):

                return False

            if any(word in out for word in ("PENDING", "RUNNING")):

                pass  # still running

            else:

                return True

        else:

            if not checks:

                print("‚ÑπÔ∏è  No CI checks present ‚Äì proceed.")

                return True

            done = all(c["status"] == "COMPLETED" for c in checks)

            success = all(c["state"] == "SUCCESS" for c in checks)

            if done and success:

                return True

            if done and not success:

                print("‚ùå Some checks failed.")

                return False

        time.sleep(CI_POLL_INTERVAL)



# -------------- main --------------------



def main() -> None:

    p = argparse.ArgumentParser(description="PR automator with CI fallback")

    p.add_argument("--message", default="")

    p.add_argument("--title",   default="")

    p.add_argument("--body",    default="")

    p.add_argument("--branch",  default="")

    p.add_argument("--base",    default="main")

    p.add_argument("--wait",    type=int, default=5)

    p.add_argument("--ci",      action="store_true", help="enable CI polling (default: disabled, merge immediately)")

    p.add_argument("--force",   action="store_true", help="admin override: merge even if checks fail (requires token permissions)")

    args = p.parse_args()



    # Check authentication before starting

    check_auth()



    # In GitHub Actions context, we're working with an existing PR

    # Try to get PR number from environment/context

    pr_num = get_current_pr_number()

    

    # If no PR found and we're in standalone mode, create PR

    if pr_num is None:

        if not args.title or not args.message:

            print("‚ùå No existing PR found and --title/--message not provided.")

            print("   In GitHub Actions, this should run on an existing PR.")

            sys.exit(1)

        

        # Standalone mode: create branch, commit, push, open PR

        if not args.branch:

            args.branch = f"feat/auto-{int(time.time())}"

        

        run(f"git checkout -B {shlex.quote(args.branch)}")

        run("git add -A")

        try:

            run(f"git commit -m {json.dumps(args.message)}")

        except subprocess.CalledProcessError:

            print("No changes ‚Äì exit.")

            sys.exit(0)

        run("git push -u origin HEAD")



        try:

            pr_num = open_pr(args.title, args.body, args.base, args.branch)

        except Exception as exc:

            print(f"‚ùå PR open error: {exc}")

            sys.exit(2)

        print(f"PR #{pr_num} opened.")

    else:

        print(f"üîÑ Working with existing PR #{pr_num}")



    time.sleep(args.wait)



    if args.ci:

        if not ci_checks_green(pr_num, CI_POLL_TIMEOUT, args.force):

            if not args.force:

                sys.exit(1)



    merge_cmd = f"gh pr merge {pr_num} --squash --delete-branch"

    if args.force:

        merge_cmd += " --admin"

        print("‚ö†Ô∏è  Using --force flag: merging with admin override (ignoring failed checks)")



    try:

        run(merge_cmd)

        print("‚úÖ Merged & branch deleted.")

    except subprocess.CalledProcessError:

        print("‚ùå Auto‚Äëmerge failed ‚Äì maybe conflict or insufficient permissions.")

        sys.exit(1)



if __name__ == "__main__":

    main()





